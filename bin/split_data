#!/usr/bin/env python

import os
import argparse
import time
import random
import shutil

from pathlib import Path
from math import ceil

from somenlp.utils import get_time_marker
from somenlp.feature_engineering import calculate_features_parallel


import os
from os import listdir 
from collections import Counter

import os
from os import listdir 
from collections import Counter

# split_data --in-path data/PLoS_methods_bio --out-path data/PLoS_methods

path_whole = '/home/beck/Desktop/SoMeNLP/data/PLoS_methods_bio/'

path_train = "/home/beck/Desktop/SoMeNLP/data/PLoS_methods/PLoS_methods_bio_train/" 

path_test = "/home/beck/Desktop/SoMeNLP/data/PLoS_methods/PLoS_methods_bio_test/" 

path_test = "/home/beck/Desktop/SoMeNLP/data/PLoS_methods/PLoS_methods_bio_devel/"

def train_test_dev(whole_path, train_path, test_path, dev_path):
    
    _whole = purposeLabel_counter(whole_path)
    _train = purposeLabel_counter(train_path)
    _test  = purposeLabel_counter(test_path)
    _dev   = purposeLabel_counter(dev_path)
    
    
    
    _whole_sorted = dict(sorted(_whole.items()))
    _train_sorted = dict(sorted(_train.items()))
    _test_sorted  = dict(sorted(_test.items()))
    _dev_sorted   = dict(sorted(_dev.items()))
    
    return _whole_sorted, _train_sorted, _test_sorted, _dev_sorted

def purposeLabel_counter(path):
    
    def list_file_names(path, file_ext='.labels.txt'):
        
        file_names_list = []
        
        for file_name in os.listdir(path):
            if not file_name.endswith(file_ext): continue  # skip if the file is not .labels.txt
            file_names_list.append(file_name) 

        file_names_list.sort()

        return file_names_list
    
    file_name_list = list_file_names(path)
    
    interest_list = ["Analysis", "Modelling", "Stimulation", "DataCollection", "DataPreProcss", "Simulation", "Visualization", "Programming"]
    
    all_purpose_labels = []
    
    for file_name in file_name_list[:]:
        file_path = path + file_name
        
        with open(file_path, 'r') as f:
            
            list_lines = f.readlines()
            
            #print(list_of_lebs)
            list_of_tokens = ' '.join(list_lines).split()
            
            for tok in list_of_tokens:
                if tok != 'O' and (len(tok.split('-')[1].split('_')) == 3 ):
                    if tok.split('-')[1].split('_')[2] in interest_list:
                        
                        purpose = tok.split('-')[1].split('_')[2]
                        
                        all_purpose_labels.append(purpose)
    
                        
    return  dict(Counter(all_purpose_labels))


def train_test_dev(whole_path, train_path, test_path, dev_path):
    
    _whole = purposeLabel_counter(whole_path)
    _train = purposeLabel_counter(train_path)
    _test  = purposeLabel_counter(test_path)
    _dev   = purposeLabel_counter(dev_path)
    
    _whole_sorted = dict(sorted(_whole.items()))
    _train_sorted = dict(sorted(_train.items()))
    _test_sorted  = dict(sorted(_test.items()))
    _dev_sorted   = dict(sorted(_dev.items()))
    
    return _whole_sorted, _train_sorted, _test_sorted, _dev_sorted


def _is_train_set_NOT_proportional(whole, train):
    
    is_not_proportional = False
    
    for (k,v), (k2,v2) in zip(whole.items(), train.items()):
        if k2 == k: 
            train_percentage = v2 / v * 100
            
            if train_percentage < 55: 
                
                print(f"Train data split is {int(train_percentage)}% below -5%, for purpose {k2} splitting again")
                
                is_not_proportional = True
                return is_not_proportional
                
            elif train_percentage > 65:
                print(f"Train data split is {int(train_percentage)}% over +5 %, for {k2} purpose splitting again")
                
                is_not_proportional = True
                return is_not_proportional
                
            else:
                #print(f"Train data split is {int(train_percentage)}% and within +/-5 % for purpose {k2}")
                pass 
            
    return is_not_proportional

def _is_test_set_NOT_proportional(whole, test):
    
    is_not_proportional = False
    
    for (k,v), (k2,v2) in zip(whole.items(), test.items()):
        if k2 == k: 
            test_percentage = v2 / v * 100
            
            if test_percentage < 15: 
                
                print(f"Test data split is {int(test_percentage)}% below -5%, for purpose {k2} splitting again")
                
                is_not_proportional = True
                return is_not_proportional
                
            elif test_percentage > 25:
                print(f"Test data split is {int(test_percentage)}% over +5 %, for purpose {k2} splitting again")
                
                is_not_proportional = True
                return is_not_proportional
            
            else:
                #print(f"Test data split is {test_percentage: .2f} and within +/-5 % for purpose {k2}")
                pass
                
    return  is_not_proportional

def _is_dev_set_NOT_proportional(whole, dev):
    
    is_not_proportional = False
    
    for (k,v), (k2,v2) in zip(whole.items(), dev.items()):
        if k2 == k: 
            dev_percentage = v2 / v * 100
            
            if dev_percentage < 15: 
                print(f"Dev data split is {int(dev_percentage)}% below -5%, for purpose {k2} splitting again")
                
                is_not_proportional = True
                return is_not_proportional
                
            elif dev_percentage > 25:
                print(f"Dev data splt is {int(dev_percentage)}% over +5 %, for purpose {k2} splitting again")
                
                is_not_proportional = True
                return is_not_proportional
            
            elif (dev_percentage >= 15) and (dev_percentage <= 25):
               
                #print(f"Dev data split is {int(dev_percentage)}% and within  +/- 5%, for purpose {k2}")
                pass
    return is_not_proportional

whole, train, test, dev = train_test_dev(path_whole, path_train, path_test, path_test)

def calculate_split_percentage(whole, train, test, dev):
    
    train_not_proportional = _is_train_set_NOT_proportional(whole, train)
    test_not_proportional  = _is_test_set_NOT_proportional(whole, test)
    dev_not_proportional   = _is_dev_set_NOT_proportional(whole, dev)
    
    # if any of train, test or dev is not within +/5 split again
    
    if (train_not_proportional or test_not_proportional or dev_not_proportional):

        

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description = "Split corpus according to a specified ratio.")
    parser.add_argument("--in-path", required=True, help="Path to input dir.")
    parser.add_argument("--out-path", required=True, help="Path to output folder (will be created if it does not exist).")
    parser.add_argument("--file-extension", default=".data.txt", help="Extension for recognizing unique files.")
    parser.add_argument("--ratio", default=[60, 20, 20], nargs='+', type=int, help="Split ratio. Provided as int and has to sum to 100, e.g., 60 20 20")
    parser.add_argument("--set-names", default=['train', 'devel', 'test'], nargs='+', help="Output set names for writing")
    args = parser.parse_args()

    args.in_path = args.in_path.rstrip('/')
    args.out_path = args.out_path.rstrip('/')

    if not os.path.isdir(args.in_path):
        raise(RuntimeError("Input path does not exist"))
    if not os.path.isdir(args.out_path):
        os.mkdir(args.out_path)
    
    if sum(args.ratio) != 100:
        raise(RuntimeError("Input ratio {} does not sum to 100".format(args.ratio)))
    if len(args.ratio) != len(args.set_names):
        raise(RuntimeError("Number of ratios and setnames has to match: {} vs {}".format(args.ratio, args.set_names)))

    print("Loading files")
    single_files = list(Path(args.in_path).rglob('*{}'.format(args.file_extension)))
    all_files = []
    for entry in single_files:
        base_file_name = entry.name.split(args.file_extension)[0]
        base_file_entries = list(Path(args.in_path).rglob('{}*'.format(base_file_name)))
        all_files.append(base_file_entries)
    
    random.seed(2)
    random.shuffle(all_files)

    print("Copying files")
    cut_sum = 0
    prev_cut_idx = 0
    for cut, name in zip(args.ratio, args.set_names):
        cut_sum += cut
        cut_idx = ceil(len(all_files) * cut_sum / 100) 
        out_folder_name = args.in_path.rsplit('/')[-1]
        new_output_location = '{}/{}_{}'.format(args.out_path.rstrip('/'), out_folder_name, name) 
        if not os.path.isdir(new_output_location):
            os.makedirs(new_output_location)
        for files in all_files[prev_cut_idx:cut_idx]:
            for f in files:
                source_path = str(f)
                target_path = '{}/{}'.format(new_output_location, f.name)
                shutil.copy(source_path, target_path)
        prev_cut_idx = cut_idx
    print("Done")
